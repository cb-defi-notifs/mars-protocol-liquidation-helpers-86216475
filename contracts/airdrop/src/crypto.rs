use std::convert::TryInto;

use bech32::{ToBase32, Variant};
use cosmwasm_std::{Api, StdError, StdResult};
use hex;
use ripemd::Ripemd160;
use sha2::{digest::Update, Digest, Sha256};

/// Generate the address corresponding to the pubkey and prefix
///
/// NOTE: Here `pubkey` shall be a hex-encoded bytearray.
///
/// NOTE: Raw address is generated by `ripemd160(sha256(pk_bytes))[:20]` according to ADR-028:
/// https://docs.cosmos.network/master/architecture/adr-028-public-key-addresses.html
pub fn pubkey_to_addr(pubkey: &str, prefix: &str) -> StdResult<String> {
    let pk_bytes = hex::decode(pubkey)
        .map_err(|err| wrap_err("[hex] failed to decode pubkey", err))?;

    let pk_hash_bytes = Sha256::new().chain(pk_bytes).finalize();
    let pk_hash_bytes = Ripemd160::new().chain(pk_hash_bytes).finalize();

    bech32::encode(prefix, pk_hash_bytes.to_base32(), Variant::Bech32)
        .map_err(|err| wrap_err("[bech32] failed to generate address", err))
}

/// Verify a secp256k1 signature
///
/// NOTE: Here `pubkey` and `signature` shall be hex-encoded bytearrays
///
/// NOTE: We assume the signature was for the SHA256 hash of the signature
pub fn verify_signature(api: &dyn Api, msg: &str, pubkey: &str, signature: &str) -> StdResult<bool> {
    let msg_hash_bytes = Sha256::new().chain(msg).finalize();

    let sig_bytes = hex::decode(signature)
        .map_err(|err| wrap_err("[hex] failed to decode signature", err))?;
    let pk_bytes = hex::decode(pubkey)
        .map_err(|err| wrap_err("[hex] failed to decode pubkey", err))?;

    api
        .secp256k1_verify(&msg_hash_bytes, &sig_bytes, &pk_bytes)
        .map_err(|err| wrap_err("[secp256k1] failed to verify signature", err))
}

/// Verify a merkle proof
///
/// NOTE: Here `merkle_proof` and `merkle_hash` shall be a hex-encoded bytearray
///
/// NOTE: We assume the leaves are SHA256 hashes of the leaf strings
pub fn verify_proof(leaf: &str, merkle_root: &str, merkle_proof: &[String])  -> StdResult<bool> {
    let hash = sha2::Sha256::digest(leaf.as_bytes())
        .as_slice()
        .try_into()
        .map_err(|_| StdError::generic_err("[merkle] hash of leaf is of wrong length"))?;

    let hash = merkle_proof.iter().try_fold(hash, |hash, p| {
        let proof_bytes: [u8; 32] = hex::decode(p)
            .map_err(|err| wrap_err("[hex] failed to decode merkle proof", err))?
            .try_into()
            .map_err(|_| StdError::generic_err("[merkle] proof is of wrong length"))?;

        let hashes = if hash < proof_bytes {
            [hash, proof_bytes]
        } else {
            [proof_bytes, hash]
        };

        sha2::Sha256::digest(&hashes.concat())
            .as_slice()
            .try_into()
            .map_err(|_| StdError::generic_err("[merkle] hash is of wrong length"))
    })?;

    let root_hash: [u8; 32] = hex::decode(merkle_root)
        .map_err(|err| wrap_err("[hex] failed to decode merkle root", err))?
        .try_into()
        .map_err(|_| StdError::generic_err("[merkle] root is of wrong length"))?;

    Ok(root_hash == hash)
}

/// Wrap an error into a `cosmwasm_std::StdError`, assuming the error type implements `ToString`
pub fn wrap_err<T: ToString>(prefix: &str, err: T) -> StdError {
    StdError::generic_err(format!("{}: {}", prefix, err.to_string()))
}

#[cfg(test)]
mod test {
    use super::*;
    use cosmwasm_std::testing::mock_dependencies;

    #[test]
    fn addr_from_pubkey() {
        let pubkey = "038c1ff4b56a1473e7b5fee736ed56cbcffc9d064de42eb15af67913ab4caf01bc";
        assert_eq!(
            pubkey_to_addr(pubkey, "terra").unwrap(),
            "terra1z926ax906k0ycsuckele6x5hh66e2m4m5udwep",
        );
        assert_eq!(
            pubkey_to_addr(pubkey, "mars").unwrap(),
            "mars1z926ax906k0ycsuckele6x5hh66e2m4m09whw6",
        );
    }

    #[test]
    fn verifying_signature() {
        let deps = mock_dependencies();

        let msg = "this is a test for mars airdrop contract";
        let pubkey = "038c1ff4b56a1473e7b5fee736ed56cbcffc9d064de42eb15af67913ab4caf01bc";

        // Signature generated by Terra Station wallet at https://larry.engineer/sign-or-verify/
        // Relevant code: https://github.com/st4k3h0us3/sign-or-verify/blob/ca026e77b4a3a220a9d6f8aa8ec4a84ff4577bc9/src/index.ts#L53-L70
        let res = verify_signature(
            &deps.api,
            msg,
            pubkey,
            "7f73595b39e4e8ed853e3fbe49ca32438e9a9b6f1f578dfa6acfda1d267c60953b749ba2b091b6058c0258db3f9231a4529651962b718b77db3e0ed8887e7cd1",
        );
        assert_eq!(res, Ok(true));

        // Invalid signature: generated by signing the message "this is a demo of invalid signature",
        // signed by the same private key
        let res = verify_signature(
            &deps.api,
            msg,
            pubkey,
            "b9e09efbbb22245cb557d8d21b9303104def9e3b06f52b7d1b4b1f485192737b1605081f9fca4746259ec5219d632f6d75ae7c94d6366375cf92c475215fbb0c",
        );
        assert_eq!(res, Ok(false));

        // Another invalid signature: same message ("this is a test for mars airdrop contract") but
        // different signer (localterra1, pubkey - `023b33a8524344061b12364cba20fe0a1ab36d4486abf451bb7cebd11ea2241e5b`)
        let res = verify_signature(
            &deps.api,
            msg,
            pubkey,
            "503c2d4b71ba39dfc5e37ae8899ac04de394d0381dae7ead5658e43e658d64761fa5819c29dfae42b253953e60fa2ec9a96abee682a418d3515ee641c611be3b"
        );
        assert_eq!(res, Ok(false));
    }

    #[test]
    fn verifying_proof() {
        let root = "a7da979c32f9ffeca6214558c560780cf06b09e52fe670f16c532b20016d7f38";

        // Test case 1 generated by `scripts/1_build_merkle_tree.ts`
        let res = verify_proof(
            "terra1757tkx08n0cqrw7p86ny9lnxsqeth0wgp0em95:42069",
            root,
            &[
                "43e1c4776372ff2136f9f8db4f2c9e8392ebd9c378bf47eeba18871309c453d7".to_string(),
                "37c71107165d3dc28551f006263453fa642d78fc013c04d2d89d96de022fde24".to_string(),
                "7089ea1db485169381b9e3539e5c61e3818b53c03a34f8f2aeecf35a3e112c3a".to_string(),
            ],
        );
        assert_eq!(res, Ok(true));

        // Test case 2 generated by `scripts/1_build_merkle_tree.ts`
        // Same proof, but the user attempts to claim a different amount (69420 rather than 42969)
        let res = verify_proof(
            "terra1757tkx08n0cqrw7p86ny9lnxsqeth0wgp0em95:69420",
            root,
            &[
                "43e1c4776372ff2136f9f8db4f2c9e8392ebd9c378bf47eeba18871309c453d7".to_string(),
                "37c71107165d3dc28551f006263453fa642d78fc013c04d2d89d96de022fde24".to_string(),
                "7089ea1db485169381b9e3539e5c61e3818b53c03a34f8f2aeecf35a3e112c3a".to_string(),
            ],
        );
        assert_eq!(res, Ok(false));

        // Test case 3 generated by `scripts/1_build_merkle_tree.ts`
        // A non-existent user is inserted into the Merkle tree
        let res = verify_proof(
            "terra17tv2hvwpg0ukqgd2y5ct2w54fyan7z0zxrm2f9:123456789",
            root,
            &[
                "f3712e76d8b9288a381de1d22720fe3673d9e2636f1c11b2b26d6e7889a78692".to_string(),
                "37c71107165d3dc28551f006263453fa642d78fc013c04d2d89d96de022fde24".to_string(),
                "bff2934478464bb50326325e6b2a2d47ba13475eccfa991e9825442b06ae7efc".to_string(),
            ],
        );
        assert_eq!(res, Ok(false));
    }
}
